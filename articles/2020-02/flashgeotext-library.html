<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Introducing flashgeotext: extract city and country names from text" /><meta name="author" content="iwpnd" /><meta property="og:locale" content="en_US" /><meta name="description" content="Say you are faced with the problem of extracting the name of a location from a text and count their occurrences. How would you do it in the simplest of manners, if you:" /><meta property="og:description" content="Say you are faced with the problem of extracting the name of a location from a text and count their occurrences. How would you do it in the simplest of manners, if you:" /><link rel="canonical" href="https://iwpnd.pw//articles/2020-02/flashgeotext-library" /><meta property="og:url" content="https://iwpnd.pw//articles/2020-02/flashgeotext-library" /><meta property="og:site_name" content="iwpnd" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-25T08:13:37+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Introducing flashgeotext: extract city and country names from text" /><meta name="twitter:site" content="@imwithpanda" /><meta name="twitter:creator" content="@imwithpanda" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"iwpnd"},"dateModified":"2020-02-25T08:13:37+00:00","datePublished":"2020-02-25T08:13:37+00:00","description":"Say you are faced with the problem of extracting the name of a location from a text and count their occurrences. How would you do it in the simplest of manners, if you:","headline":"Introducing flashgeotext: extract city and country names from text","mainEntityOfPage":{"@type":"WebPage","@id":"https://iwpnd.pw//articles/2020-02/flashgeotext-library"},"url":"https://iwpnd.pw//articles/2020-02/flashgeotext-library"}</script><title> Introducing flashgeotext&amp;#58; extract city and country names from text - iwpnd</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="iwpnd" href="/atom.xml"><link rel="alternate" type="application/json" title="iwpnd" href="https://iwpnd.pw//feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.highlight{background:#282a36;color:#f8f8f2;font-size:.8rem}.highlight .hll,.highlight .s,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .dl,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss{color:#f1fa8c}.highlight .go{color:#44475a}.highlight .err,.highlight .g,.highlight .l,.highlight .n,.highlight .x,.highlight .p,.highlight .ge,.highlight .gr,.highlight .gh,.highlight .gi,.highlight .gp,.highlight .gs,.highlight .gu,.highlight .gt,.highlight .ld,.highlight .no,.highlight .nd,.highlight .ni,.highlight .ne,.highlight .nn,.highlight .nx,.highlight .py,.highlight .w,.highlight .bp{color:#f8f8f2}.highlight .gh,.highlight .gi,.highlight .gu{font-weight:bold}.highlight .ge{text-decoration:underline}.highlight .bp{font-style:italic}.highlight .c,.highlight .ch,.highlight .cm,.highlight .cpf,.highlight .c1,.highlight .cs{color:#6272a4}.highlight .kd,.highlight .kt,.highlight .nb,.highlight .nl,.highlight .nv,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#8be9fd}.highlight .kd,.highlight .nb,.highlight .nl,.highlight .nv,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{font-style:italic}.highlight .na,.highlight .nc,.highlight .nf,.highlight .fm{color:#50fa7b}.highlight .k,.highlight .o,.highlight .cp,.highlight .kc,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .nt,.highlight .ow{color:#ff79c6}.highlight .m,.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .il{color:#bd93f9}.highlight .gd{color:#f55}</style></head><body><main role="main"><header role="banner"> <img src="/img/iwpnd-logo.png" alt="iwpnd logo"><nav role="navigation"><ul><li><a href="/" >blog</a></li><li><a href="/til" >til</a></li><li><a href="/about" >about</a></li><li><a href="/search" >search</a></li><li><a href="/imprint" >imprint</a></li></ul></nav></header><script async src="https://www.googletagmanager.com/gtag/js?id=UA-156087226-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-156087226-1'); </script><section class="post"><h2>Introducing flashgeotext&#58; extract city and country names from text</h2><p>Say you are faced with the problem of extracting the name of a location from a text and count their occurrences. How would you do it in the simplest of manners, if you:</p><ol><li>Have a list of names that you want to extract (10.000+)</li><li>Don’t care about any other name in your text, because you know what you are looking for</li><li>Are on a budget</li><li>Want to optimize for execution time</li></ol><h1 id="tldr">tl;dr</h1><p>Go to <a href="https://flashgeotext.iwpnd.pw">https://flashgeotext.iwpnd.pw</a>, ignore all that and use it right away.</p><h2 id="lets-brute-force-it">Let’s brute force it</h2><p>Let’s brute for this problem and check every word in a lookup against an input text.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lookup</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Berlin'</span><span class="p">,</span> <span class="s">'Hamburg'</span><span class="p">,</span> <span class="s">'London'</span><span class="p">,</span> <span class="s">'New York'</span><span class="p">,</span> <span class="p">[...]]</span>
<span class="n">input_text</span> <span class="o">=</span> <span class="s">"Berlin is a great city. Berlin is not as nice as Erlangen, but will do for now."</span>

<span class="c1"># check if lookup in input_text
</span><span class="n">isin_text</span> <span class="o">=</span> <span class="p">[</span><span class="n">city</span> <span class="ow">in</span> <span class="n">input_text</span> <span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">lookup</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">isin_text</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">]</span>
</code></pre></div></div><p>Now you know that Berlin and New York are mentioned in the text. But you don’t know how often. So maybe you think of something like:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lookup</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Berlin'</span><span class="p">,</span> <span class="s">'Hamburg'</span><span class="p">,</span> <span class="s">'London'</span><span class="p">,</span> <span class="s">'New York'</span><span class="p">]</span>
<span class="n">input_text</span> <span class="o">=</span> <span class="s">"Berlin is a great city. Berlin is not as nice as New York, but will do for now."</span>

<span class="n">extract</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">lookup</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">input_text</span><span class="p">.</span><span class="n">split</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">word</span> <span class="o">==</span> <span class="n">city</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">city</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extract</span><span class="p">:</span>
                <span class="n">extract</span><span class="p">[</span><span class="n">city</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"count"</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extract</span><span class="p">[</span><span class="n">city</span><span class="p">][</span><span class="s">"count"</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract</span><span class="p">[</span><span class="n">city</span><span class="p">][</span><span class="s">"count"</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                
<span class="k">print</span><span class="p">(</span><span class="n">extract</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="p">{</span><span class="s">'Berlin'</span><span class="p">:</span> <span class="p">{</span><span class="s">'count'</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
</code></pre></div></div><p>If your eyes are already bleeding, wipe that away and stick with me some more. Now we have a count for the occurrences of <em>Berlin</em> but are missing <em>New York</em> entirely because we’re iterating over a sequence of <a href="https://en.wikipedia.org/wiki/N-gram">unigrams</a> but to match <em>New York</em> we would have to check <a href="https://en.wikipedia.org/wiki/N-gram">bigrams</a> of the words in the input text. If we were to look up something like <em>Costa del Sol</em>, it would take <a href="https://en.wikipedia.org/wiki/N-gram">trigrams</a> and so on. With some recursive function you might be able to abuse the <code class="language-plaintext highlighter-rouge">find()</code> method of Python strings to avoid the use of <a href="https://en.wikipedia.org/wiki/N-gram">n-grams</a>, but before we go down that route we cut the conclusion short and say that brute-forcing is not the way to go. At best you’re left with <strong><code class="language-plaintext highlighter-rouge">M * N</code></strong> calculations - that is when you’re checking for unigrams. That means every word in the lookup, will be checked against every word of the input text.</p><h2 id="what-now-named-entity-extraction">What now? Named Entity Extraction!</h2><p>To reduce the number of calculations and to avoid the use of n-grams, we have to reduce either <strong><code class="language-plaintext highlighter-rouge">M</code></strong> (the number of words in the lookup) or reduce <strong><code class="language-plaintext highlighter-rouge">N</code></strong> the words in the input text. Reducing <strong><code class="language-plaintext highlighter-rouge">M</code></strong> is off the table, because that’s what we’re looking for. Reducing <strong><code class="language-plaintext highlighter-rouge">N</code></strong> is something we can do though. Cities, countries, and districts are all <a href="https://en.wikipedia.org/wiki/Named_entity">named entities</a>. And Named Entities can be extracted, reducing <strong><code class="language-plaintext highlighter-rouge">N</code></strong> in the process.</p><h3 id="spacy">spaCy</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">spacy</span>

<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">"en_core_web_sm"</span><span class="p">)</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="s">"Berlin is an awesome city. It is also great to live in London though."</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">.</span><span class="n">ents</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">ent</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">start_char</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">end_char</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">label_</span><span class="p">)</span>

<span class="o">&gt;&gt;</span> <span class="n">Berlin</span> <span class="mi">0</span> <span class="mi">6</span> <span class="n">GPE</span>
<span class="o">&gt;&gt;</span> <span class="n">London</span> <span class="mi">55</span> <span class="mi">61</span> <span class="n">GPE</span>
</code></pre></div></div><p><a href="https://github.com/explosion/spaCy">spaCy</a> is awesome. It supports a lot of languages. It’s easy to learn, hard to master. It’s super well documented and embedded into a great community and a great ecosystem of plugins/addons/spinoffs. It has a lot of functionality aside from named entity extraction. And it does what it is supposed to do and more. However, named entity extraction with spaCy is still based on a trained model prediction, and even though the core models perform well, they are not 100% accurate. On top of that spaCy is build with C dependencies, which can be a problem in some environments. Also, you are limited to the pre-trained models, unless you want to train your language model from scratch.</p><p>Using spaCy limits us to a limited amount of languages that are supported. Locations that are parsed from an input text and returned by spaCy would still need to be checked against a lookup. Slight variations in the input text would drastically change the result.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">spacy</span>

<span class="n">nlp</span> <span class="o">=</span> <span class="n">spacy</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">"en_core_web_sm"</span><span class="p">)</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="s">"Berlin city is awesome. But now imagine you live in London city."</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">.</span><span class="n">ents</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">ent</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">start_char</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">end_char</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">label_</span><span class="p">)</span>

<span class="o">&gt;&gt;</span> <span class="n">Berlin</span> <span class="n">city</span> <span class="mi">0</span> <span class="mi">11</span> <span class="n">GPE</span>
<span class="o">&gt;&gt;</span> <span class="n">London</span> <span class="n">city</span> <span class="mi">52</span> <span class="mi">63</span> <span class="n">GPE</span>
</code></pre></div></div><p>Also, there would have to be a process to calculate the occurrences. Spacys dependencies make it harder (not impossible) to deploy in a low-cost environment such as AWS Lambda.</p><h3 id="geotext">GeoText</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">geotext</span> <span class="kn">import</span> <span class="n">GeoText</span>

<span class="n">places</span> <span class="o">=</span> <span class="n">GeoText</span><span class="p">(</span><span class="s">"London is a great city"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">cities</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="s">"London"</span>
</code></pre></div></div><p><a href="https://github.com/elyase/geotext">GeoText</a> relies on a single regex search pattern to extract named entities from an input text. Afterward, GeoText tries to match every single one of the entities found to a collection of city and country names one by one. This approach is fast for the 22.000 cities that come with the library, but do not scale well with longer texts and more cities/keywords in a lookup file. <a href="https://github.com/elyase/geotext">GeoText</a> also does not make it easy to bring your data. Also, synonyms are not in the scope of <a href="https://github.com/elyase/geotext">GeoText</a>. Another problem is the regex search pattern that extracts named entities. It is a fine line between matching correctly and matching too much, and it gets even harder to match when city names contain more than a couple of words. Have fun matching something like <em>Friendly Village of Crooked Creek</em>.</p><p>Nonetheless, <a href="https://github.com/elyase/geotext">GeoText</a> comes very close to what I had in mind. <a href="https://github.com/elyase/geotext">GeoText</a> provides named entity recognition, even though it has its flaws. It provides some sample data from Geonames that can work as a lookup. It is a native python implementation and will run anywhere. Where <a href="https://github.com/elyase/geotext">GeoText</a> struggles is that it comes batteries included but doesn’t provide you an opening to bring your data. Also, the regex statement has its limits.</p><h3 id="conclusion">Conclusion</h3><p>By extracting named entities we reduce the number of computations necessary to look up keywords in a text tremendously. However reducing the number of computations is of no great use, if we can’t match the lookup against the extracted entities. Spacy is a great framework, but not the tool for the job. GeoText looks like the tool for the job but is flawed when it comes to entity extraction and flexibility.</p><h2 id="aaand-now">Aaand now?</h2><p>What if instead of reducing <strong><code class="language-plaintext highlighter-rouge">N</code></strong> the number of words in the text to check against a lookup explicitly? What if we would be able to go over the input text, character by character, in one go and would only perform an action if the character is</p><p>a) the start of a word, ergo follows a non-word character and <br /> b) the character is even present in our list of keywords to lookup?</p><h3 id="flashtext-an-aho-corasick-implementation">FlashText an Aho-Corasick implementation</h3><p><a href="https://github.com/vi3k6i5/flashtext/">FlashText</a> (see <a href="https://arxiv.org/pdf/1711.00046.pdf">paper</a>) is loosely based on the <a href="https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm">Aho-Corasick Algorithm</a> used in string-searching. Using the keywords in the lookup data a Trie dictionary is built. The tree is grown by adding edges down from node to node where edges are comprised of letters in each of the strings being added.</p><p align="center"> <img src="/img/2020-02-flashgeotext/aho-random-trie.png" alt="aho random trie" />source: <a href="https://banay.me/post/aho-corasick/">banay.me</a></p><p>This allows it to iterate over the input text character by character, and only if the character matches the trie dictionary from start to finish a match is found and stored separately.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flashtext</span> <span class="kn">import</span> <span class="n">KeywordProcessor</span>

<span class="n">lookup</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Berlin'</span><span class="p">,</span> <span class="s">'Hamburg'</span><span class="p">,</span> <span class="s">'London'</span><span class="p">,</span> <span class="s">'New York'</span><span class="p">]</span>
<span class="n">input_text</span> <span class="o">=</span> <span class="s">"Berlin is a great city. Berlin is not as nice as New York, but will do for now."</span>

<span class="n">processor</span> <span class="o">=</span> <span class="n">KeywordProcessor</span><span class="p">(</span><span class="n">case_sensitive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">processor</span><span class="p">.</span><span class="n">add_keywords_from_list</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
<span class="n">processor</span><span class="p">.</span><span class="n">extract_keywords</span><span class="p">(</span><span class="n">input_text</span><span class="p">,</span> <span class="n">span_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="o">&gt;&gt;</span> <span class="p">[(</span><span class="s">'Berlin'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="s">'Berlin'</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="s">'New York'</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">57</span><span class="p">)]</span>
</code></pre></div></div><p>This makes FlashText super fast compared to other approaches.</p><p align="center"> <img src="/img/2020-02-flashgeotext/flashtext-vs-regex.png" alt="flashtext vs regex" />source: <a href="https://github.com/vi3k6i5/flashtext/">github.com/vi3k6i5/flashtext/</a></p><h2 id="flashgeotext">Flashgeotext</h2><p><a href="https://github.com/iwpnd/flashgeotext">flashgeotext</a> is my approach in making something good like FlashText, even better by adding some quality of life add-ons to it. It is also intended as a homage to <a href="https://github.com/elyase/geotext">GeoText</a> following a <a href="https://github.com/elyase/geotext/issues/22">discussion</a> late last year.</p><h3 id="features">Features</h3><h4 id="batteries-included-lookup">batteries included lookup</h4><p><a href="https://github.com/iwpnd/flashgeotext">flashgeotext</a> comes with batteries included. Just like GeoText, you can add city names from <a href="https://geonames.org">geonames.org</a> as a lookup by default and start going right away.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flashgeotext.geotext</span> <span class="kn">import</span> <span class="n">GeoText</span>

<span class="n">geotext</span> <span class="o">=</span> <span class="n">GeoText</span><span class="p">(</span><span class="n">use_demo_data</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">input_text</span> <span class="o">=</span> <span class="s">'''Shanghai. The Chinese Ministry of Finance in Shanghai said that China plans
                to cut tariffs on $75 billion worth of goods that the country
                imports from the US. Washington welcomes the decision.'''</span>

<span class="n">geotext</span><span class="p">.</span><span class="n">extract</span><span class="p">(</span><span class="n">input_text</span><span class="o">=</span><span class="n">input_text</span><span class="p">,</span> <span class="n">span_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="s">'cities'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'Shanghai'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'count'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s">'span_info'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">53</span><span class="p">)]</span>
            <span class="p">},</span>
        <span class="s">'Washington, D.C.'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'count'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s">'span_info'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">175</span><span class="p">,</span> <span class="mi">185</span><span class="p">)]</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="s">'countries'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'China'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'count'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s">'span_info'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">69</span><span class="p">)]</span>
            <span class="p">},</span>
        <span class="s">'United States'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'count'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s">'span_info'</span><span class="p">:</span> <span class="p">[(</span><span class="mi">171</span><span class="p">,</span> <span class="mi">173</span><span class="p">)]</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><h4 id="improved-data-handling">improved data handling</h4><p align="center"> <img src="/img/2020-02-flashgeotext/flashgeotext-diagram-notext.png" alt="flashtext structure" /></p><p>The idea is to provide a way to add additional data to the already provided data from Geonames or use your data for the lookup entirely. This is achieved by utilizing a quasi <a href="https://github.com/faif/python-patterns/blob/master/patterns/structural/composite.py">composite pattern</a>. You instantiate <code class="language-plaintext highlighter-rouge">LookupData</code> with your data (see <a href="https://flashgeotext.iwpnd.pw/usage/#bring-your-own-data">example</a>) and add that instance to a <code class="language-plaintext highlighter-rouge">LookupDataPool</code>, which is just a collection of <code class="language-plaintext highlighter-rouge">flashtext.KeywordProcessor</code>’s. On <code class="language-plaintext highlighter-rouge">extract()</code> for every <code class="language-plaintext highlighter-rouge">LookupData</code> in the pool there is one passing and extraction over the text, which amounts to the complexity of O(N * number of LookupData). The extracted data is parsed, occurrences are counted, and span information stored and returned.</p><h4 id="small-footprint-and-no-dependencies">small footprint and no dependencies</h4><p>Just like FlashText, flashgeotext does not have any big dependencies which make it easy to use in AWS Lambda and/or AWS Step functions. Once instantiated on a warm AWS Lambda/Stepfunction, it can be reused again and again. You can easily put every city name on earth into a trie dictionary and run it inside an AWS Lambda’s 3072mb of memory.</p><h4 id="non-word-boundaries">non-word-boundaries</h4><p>FlashText’s non-word boundaries that are essential in during keyword extraction are comprised of</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">non_word_boundaries</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">digits</span> <span class="o">+</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="s">'_'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">non_word_boundaries</span><span class="p">)</span>

<span class="o">&gt;&gt;</span> <span class="p">{</span><span class="s">'k'</span><span class="p">,</span> <span class="s">'6'</span><span class="p">,</span> <span class="s">'s'</span><span class="p">,</span> <span class="s">'M'</span><span class="p">,</span> <span class="s">'i'</span><span class="p">,</span> <span class="s">'S'</span><span class="p">,</span> <span class="s">'m'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="s">'W'</span><span class="p">,</span> <span class="s">'v'</span><span class="p">,</span> <span class="s">'l'</span><span class="p">,</span> 
<span class="s">'R'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">'X'</span><span class="p">,</span> <span class="s">'7'</span><span class="p">,</span> <span class="s">'3'</span><span class="p">,</span> <span class="s">'q'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">,</span> <span class="s">'0'</span><span class="p">,</span> <span class="s">'x'</span><span class="p">,</span> <span class="s">'V'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">,</span> 
<span class="s">'I'</span><span class="p">,</span> <span class="s">'4'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'z'</span><span class="p">,</span> <span class="s">'G'</span><span class="p">,</span> <span class="s">'L'</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'T'</span><span class="p">,</span> <span class="s">'U'</span><span class="p">,</span> <span class="s">'_'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'Q'</span><span class="p">,</span> 
<span class="s">'d'</span><span class="p">,</span> <span class="s">'9'</span><span class="p">,</span> <span class="s">'h'</span><span class="p">,</span> <span class="s">'o'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">,</span> <span class="s">'P'</span><span class="p">,</span> <span class="s">'K'</span><span class="p">,</span> <span class="s">'Y'</span><span class="p">,</span> <span class="s">'p'</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'J'</span><span class="p">,</span> <span class="s">'O'</span><span class="p">,</span> 
<span class="s">'N'</span><span class="p">,</span> <span class="s">'H'</span><span class="p">,</span> <span class="s">'j'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'Z'</span><span class="p">,</span> <span class="s">'5'</span><span class="p">,</span> <span class="s">'1'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'y'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">,</span> <span class="s">'8'</span><span class="p">,</span> <span class="s">'g'</span><span class="p">}</span>
</code></pre></div></div><p>This has been are-occurring <a href="https://github.com/vi3k6i5/flashtext/issues/87">issue</a> in the past. The fact that there are a lot of characters missing, makes it, that FlashText is unreliable at best for every other language than English. I’m currently working on handling different alphabets within flashgeotext to make it possible to reliably extract keywords from a text written in Cyrillic or Greek characters also.</p><h1 id="conclusion-1">Conclusion</h1><p>Flashgeotext can help you to extract city and country names in your text processing pipelines. It gives you the ability to add your data instead of or on top of the demo data provided. It is incredibly fast, reliable, written in native Python and easy to set up in an AWS Lambda/Stepfunction environment or as <a href="https://airflow.apache.org/">Airflow</a> / <a href="https://github.com/spotify/luigi">Luigi</a> / <a href="https://www.prefect.io/">Prefect</a> directed acyclic graph.</p><span class="meta"><time datetime="2020-02-25T08:13:37+00:00">February 25, 2020</time> &middot; <a href="/tag/python">python</a>, <a href="/tag/pytest">pytest</a>, <a href="/tag/flashgeotext">flashgeotext</a></span></section></main></body></html>
