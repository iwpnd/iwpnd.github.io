<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Stop killing kittens. Or, how to use pytest.fixtures to remove redundancy in your test suite" /><meta name="author" content="iwpnd" /><meta property="og:locale" content="en_US" /><meta name="description" content="Last week I wrote about how pytest.mark.parametrizing can be used to remove some redundancy in your test suite. Today let’s talk pytest.fixture and how it helps you to clean up the mess that is your test suite with reusable variables, connections and/or objects." /><meta property="og:description" content="Last week I wrote about how pytest.mark.parametrizing can be used to remove some redundancy in your test suite. Today let’s talk pytest.fixture and how it helps you to clean up the mess that is your test suite with reusable variables, connections and/or objects." /><link rel="canonical" href="https://iwpnd.pw//articles/2020-02/pytest-fixtures" /><meta property="og:url" content="https://iwpnd.pw//articles/2020-02/pytest-fixtures" /><meta property="og:site_name" content="iwpnd" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-20T08:13:37+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Stop killing kittens. Or, how to use pytest.fixtures to remove redundancy in your test suite" /><meta name="twitter:site" content="@imwithpanda" /><meta name="twitter:creator" content="@imwithpanda" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"iwpnd"},"dateModified":"2020-02-20T08:13:37+00:00","datePublished":"2020-02-20T08:13:37+00:00","description":"Last week I wrote about how pytest.mark.parametrizing can be used to remove some redundancy in your test suite. Today let’s talk pytest.fixture and how it helps you to clean up the mess that is your test suite with reusable variables, connections and/or objects.","headline":"Stop killing kittens. Or, how to use pytest.fixtures to remove redundancy in your test suite","mainEntityOfPage":{"@type":"WebPage","@id":"https://iwpnd.pw//articles/2020-02/pytest-fixtures"},"url":"https://iwpnd.pw//articles/2020-02/pytest-fixtures"}</script><title> Stop killing kittens. Or, how to use pytest.fixtures to remove redundancy in your test suite - iwpnd</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="iwpnd" href="/atom.xml"><link rel="alternate" type="application/json" title="iwpnd" href="https://iwpnd.pw//feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.highlight{background:#282a36;color:#f8f8f2;font-size:.8rem}.highlight .hll,.highlight .s,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .dl,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss{color:#f1fa8c}.highlight .go{color:#44475a}.highlight .err,.highlight .g,.highlight .l,.highlight .n,.highlight .x,.highlight .p,.highlight .ge,.highlight .gr,.highlight .gh,.highlight .gi,.highlight .gp,.highlight .gs,.highlight .gu,.highlight .gt,.highlight .ld,.highlight .no,.highlight .nd,.highlight .ni,.highlight .ne,.highlight .nn,.highlight .nx,.highlight .py,.highlight .w,.highlight .bp{color:#f8f8f2}.highlight .gh,.highlight .gi,.highlight .gu{font-weight:bold}.highlight .ge{text-decoration:underline}.highlight .bp{font-style:italic}.highlight .c,.highlight .ch,.highlight .cm,.highlight .cpf,.highlight .c1,.highlight .cs{color:#6272a4}.highlight .kd,.highlight .kt,.highlight .nb,.highlight .nl,.highlight .nv,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#8be9fd}.highlight .kd,.highlight .nb,.highlight .nl,.highlight .nv,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{font-style:italic}.highlight .na,.highlight .nc,.highlight .nf,.highlight .fm{color:#50fa7b}.highlight .k,.highlight .o,.highlight .cp,.highlight .kc,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .nt,.highlight .ow{color:#ff79c6}.highlight .m,.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .il{color:#bd93f9}.highlight .gd{color:#f55}</style></head><body><main role="main"><header role="banner"> <img src="/img/iwpnd-logo.png" alt="iwpnd logo"><nav role="navigation"><ul><li><a href="/" >blog</a></li><li><a href="/til" >til</a></li><li><a href="/about" >about</a></li><li><a href="/search" >search</a></li><li><a href="/imprint" >imprint</a></li></ul></nav></header><script async src="https://www.googletagmanager.com/gtag/js?id=UA-156087226-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-156087226-1'); </script><section class="post"><h2>Stop killing kittens. Or, how to use pytest.fixtures to remove redundancy in your test suite</h2><p>Last week I wrote about how <a href="https://iwpnd.pw/articles/2020-02/pytest-parametrize">pytest.mark.parametrizing</a> can be used to remove some redundancy in your test suite. Today let’s talk <code class="language-plaintext highlighter-rouge">pytest.fixture</code> and how it helps you to clean up the mess that is your test suite with reusable variables, connections and/or objects.</p><p align="center"> <img src="/img/2020-02-pytest-fixtures/duplication-kills-kittens.jpg" alt="duplication kills kittens" /></p><h2 id="stop-killing-kittens-with-pytestfixture">stop killing kittens with pytest.fixture</h2><p>If you <a href="https://www.obeythetestinggoat.com/">obey the testing goat</a> like you should, you practice Test-Driven-Development. Therefore you make sure to code in small incremental steps. During the refactoring phase, you will notice that repetition is omnipresent. You always pass the same data to the tests and you often instantiate the same objects. However, instead of running the same code for every test, you can attach so-called fixture functions to the test, that run and return the data to the test when needed in a reliable, consistent and repeatable manner.</p><p>Let’s try this in an example.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">foo</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bar</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="n">bar</span>
</code></pre></div></div><p>So, you have a class <code class="language-plaintext highlighter-rouge">MyClass</code> and you always use the same instance of the class in your test suite.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_myclass.py
</span><span class="kn">import</span> <span class="nn">MyClass</span>

<span class="k">def</span> <span class="nf">test_myclass_1</span><span class="p">():</span>
    <span class="n">myclass</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Panda"</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">myclass</span><span class="p">.</span><span class="n">foo</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">==</span> <span class="mi">37</span>

<span class="k">def</span> <span class="nf">test_myclass_2</span><span class="p">():</span>
    <span class="n">myclass</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Panda"</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">myclass</span><span class="p">.</span><span class="n">bar</span> <span class="o">-</span> <span class="mi">24</span> <span class="o">==</span> <span class="mi">13</span>
</code></pre></div></div><p>Instead of instantiating MyClass on every test, you can add a <code class="language-plaintext highlighter-rouge">pytest.fixture</code> and pass it as an argument to every test. Fixture functions are registered by marking them with <code class="language-plaintext highlighter-rouge">@pytest.fixture</code>.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># test_myclass.py
</span><span class="kn">import</span> <span class="nn">MyClass</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">myclass</span><span class="p">():</span>
    <span class="n">myclass</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Panda"</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">myclass</span>

<span class="k">def</span> <span class="nf">test_myclass_1</span><span class="p">(</span><span class="n">myclass</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">myclass</span><span class="p">.</span><span class="n">foo</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">==</span> <span class="mi">37</span>

<span class="k">def</span> <span class="nf">test_myclass_2</span><span class="p">(</span><span class="n">myclass</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">myclass</span><span class="p">.</span><span class="n">bar</span> <span class="o">-</span> <span class="mi">24</span> <span class="o">==</span> <span class="mi">13</span>

</code></pre></div></div><p>Now pytest finds the <code class="language-plaintext highlighter-rouge">test_myclass_1</code> and <code class="language-plaintext highlighter-rouge">test_myclass_2</code> test functions, because of the <code class="language-plaintext highlighter-rouge">test_</code> prefix. The test functions need a function argument named <code class="language-plaintext highlighter-rouge">myclass</code>. A matching fixture function is discovered by looking for a fixture-marked function named <code class="language-plaintext highlighter-rouge">myclass</code>. Pytest calls <code class="language-plaintext highlighter-rouge">myclass()</code> to create an instance of <code class="language-plaintext highlighter-rouge">MyClass</code> and returns the instance to either test function.</p><p>Defining the fixture within <code class="language-plaintext highlighter-rouge">test_myclass.py</code> comes with the trade-off that you limit the scope of your fixture to the <code class="language-plaintext highlighter-rouge">test_myclass.py</code> test file - it cannot be used in another test file that way. So what do you do? Define the same fixture in another class? No, that would cause code repetition again. Luckily <code class="language-plaintext highlighter-rouge">pytest</code> has a solution for that.</p><h2 id="conftest">conftest</h2><p>To make fixtures available to your entire test suite you use a <code class="language-plaintext highlighter-rouge">conftest.py</code> file in your tests folder. In this file you store the fixtures you plan to use across your tests.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># conftest.py
</span><span class="kn">import</span> <span class="nn">pytest</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">myclass</span><span class="p">():</span>
    <span class="n">myclass</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Panda"</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">37</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">myclass</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└── tests
    ├── conftest.py
    ├── integration
    │   └── test_integration.py
    └── unit
        ├── test_myclass_1.py
        └── test_myclass_2.py
</code></pre></div></div><p>Now that <code class="language-plaintext highlighter-rouge">conftest.py</code> is present. For every test function that has <code class="language-plaintext highlighter-rouge">myclass</code>, pytest will pass the return value of <code class="language-plaintext highlighter-rouge">myclass()</code> fixture to the test function.</p><h2 id="conclusion">conclusion</h2><p>Stop killing kittens.</p><p>Instead leverage fixtures and the concept of dependency injection, which means that an object (the fixture) supplies the dependencies to another object (the test function). This concept makes for a very modular, better manageable and repetition-free test suites.</p><span class="meta"><time datetime="2020-02-20T08:13:37+00:00">February 20, 2020</time> &middot; <a href="/tag/python">python</a>, <a href="/tag/pytest">pytest</a></span></section></main></body></html>
